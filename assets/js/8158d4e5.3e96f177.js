"use strict";(self.webpackChunkdannyjiajia_github_io=self.webpackChunkdannyjiajia_github_io||[]).push([[8955],{5752:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>f});var i=e(8650),o=e(4848),a=e(8453);const s={title:"\u7528Lua\u5b9e\u73b0A*\u5bfb\u8def\u7b97\u6cd5",date:new Date("2016-07-22T19:37:17.000Z"),tags:["Lua"]},r="\u5b9e\u73b0",l={authorsImageUrls:[]},f=[];function d(n){const t={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["\u5173\u4e8eA*\u5bfb\u8def\u7684\u7b97\u6cd5\u53c2\u8003\u8fd9\u7bc7",(0,o.jsx)(t.a,{href:"http://www.cnblogs.com/zhoug2020/p/3468167.html",children:"\u6587\u7ae0"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lua",children:'-------------------------------------------------------------------------------\n-- \u9884\u5b9a\u4e49\u5de5\u5177\u7c7b\n-------------------------------------------------------------------------------\n-- \u5b9a\u4e49\u7c7b\nfunction class(classname, super)\n    local superType = type(super)\n    local cls\n\n    if superType ~= "function" and superType ~= "table" then\n        superType = nil\n        super = nil\n    end\n\n    if superType == "function" or (super and super.__ctype == 1) then\n        -- inherited from native C++ Object\n        cls = {}\n\n        if superType == "table" then\n            -- copy fields from super\n            for k,v in pairs(super) do cls[k] = v end\n            cls.__create = super.__create\n            cls.super    = super\n        else\n            cls.__create = super\n            cls.ctor = function() end\n        end\n\n        cls.__cname = classname\n        cls.__ctype = 1\n\n        function cls.new(...)\n            local instance = cls.__create(...)\n            -- copy fields from class to native object\n            for k,v in pairs(cls) do instance[k] = v end\n            instance.class = cls\n            instance:ctor(...)\n            return instance\n        end\n\n    else\n        -- inherited from Lua Object\n        if super then\n            cls = {}\n            setmetatable(cls, {__index = super})\n            cls.super = super\n        else\n            cls = {ctor = function() end}\n        end\n\n        cls.__cname = classname\n        cls.__ctype = 2 -- lua\n        cls.__index = cls\n\n        function cls.new(...)\n            local instance = setmetatable({}, cls)\n            instance.class = cls\n            instance:ctor(...)\n            return instance\n        end\n    end\n\n    return cls\nend\n\n-- \u5224\u65ad\u662f\u5426\u662f\u7c7b\u7684\u5b9e\u4f8b\nfunction iskindof(obj, classname)\n    local t = type(obj)\n    local mt\n    if t == "table" then\n        mt = getmetatable(obj)\n    end\n\n    while mt do\n        if mt.__cname == classname then\n            return true\n        end\n        mt = mt.super\n    end\n\n    return false\nend\n\n-------------------------------------------------------------------------------\n-- \u903b\u8f91\n-------------------------------------------------------------------------------\n\nlocal ASSERT_FUNC = function(op)\n    assert(op,string.format("error:%s",debug.getinfo(1).name))\nend\n\n-- Point\nlocal PathPoint = class("PathPoint")\n\nfunction PathPoint:ctor(x,y)\n    self:setX(x)\n    self:setY(y)\nend\n\nfunction PathPoint:setX(x)\n    self.x = x\nend\n\nfunction PathPoint:getX()\n    return self.x\nend\n\nfunction PathPoint:setY(y)\n    self.y = y\nend\n\nfunction PathPoint:getY()\n    return self.y\nend\n\nfunction PathPoint:getXY()\n    return self:getX(),self:getY()\nend\n\nfunction PathPoint:setG(g)\n    self.g = g\nend\n\nfunction PathPoint:getG()\n    return self.g or 0\nend\n\nfunction PathPoint:setH(h)\n    self.h = h\nend\n\nfunction PathPoint:getH()\n    return self.h\nend\n\nfunction PathPoint:getF()\n\n    return (self:getG() and self:getH()) and (self:getG() + self:getH()) or 0\nend\n\nfunction PathPoint:setParent(point)\n    ASSERT_FUNC(iskindof(point, "PathPoint"))\n    self.parent = point\nend\n\nfunction PathPoint:getParent()\n    return self.parent\nend\n\nfunction PathPoint:generalPointString()\n    local infoString = string.format("PathPoint:[%s]@F|G|H:[%s %s %s]",\n        self:ID(),\n        tostring((self:getF() and self:getF() or  "unkown")),\n        tostring((self:getG() and self:getG() or  "unkown")),\n        tostring((self:getH() and self:getH() or  "unkown")))\n    if self:getParent() then\n        infoString = string.format("%s\\nPathPoint:[%s]@Parent:%s",\n            infoString,\n            self:ID(),\n            self:getParent():generalPointString())\n    end\n    return infoString\nend\n\nfunction PathPoint:ID()\n    return string.format("%d_%d",self:getX(),self:getY())\nend\n\nPathPoint.__tostring = function(point)\n    return point:generalPointString()\nend \n\n\n-- Pathfinding 2D\nlocal Pathfinding = class("Pathfinding")\n\n\nfunction Pathfinding:ctor(mapData,reachableFunction)\n    self.m_openList = {}\n    self.m_closedList = {}\n    self:setMapData(mapData)\n    self:setReachableFunction(reachableFunction)\nend\n\n-- private functions\n\nfunction Pathfinding:listAddPoint_(list,point)\n    ASSERT_FUNC(type(list) == \'table\' and iskindof(point,"PathPoint"))\n    list[point:ID()] = point\nend\n\nfunction Pathfinding:listRemovePoint_(list,point)\n    ASSERT_FUNC(type(list) == \'table\' and iskindof(point,"PathPoint"))\n    if list[point:ID()] then list[point:ID()] = nil end\nend\n\nfunction Pathfinding:listGetMinFPoint(list)\n    ASSERT_FUNC(type(list) == \'table\')\n    local __,ret = next(list)\n    for __,p in pairs(list) do\n        if iskindof(p, "PathPoint") then\n            if p:getF() < ret:getF() then\n                ret = p\n            end\n        end\n    end\n    return ret\nend\n\nfunction Pathfinding:listContainsPoint(list,point)\n    ASSERT_FUNC(type(list) == \'table\' and iskindof(point,"PathPoint"))\n    return list[point:ID()]\nend\n\nfunction Pathfinding:listIsEmpty(list)\n    ASSERT_FUNC(type(list) == \'table\')\n    return not next(list)\nend\n\n-- logic private methods\n\nfunction Pathfinding:canReach(point,x,y)\n    if not self:isReachableByXY(x,y)  or self:isCloseListContainsPoint(PathPoint.new(x,y)) then return false end\n    return math.abs(point:getX() - x) + math.abs(point:getY() - y) == 1\nend\n\nfunction Pathfinding:getSurroundPoints(point)\n    ASSERT_FUNC(iskindof(point,"PathPoint"))\n    local ret = {}\n    for x = point:getX()-1,point:getX()+1 do\n        for y = point:getY()-1,point:getY()+1 do\n            if self:canReach(point,x,y) then\n                table.insert(ret, PathPoint.new(x,y))\n            end\n        end\n    end\n    return ret\nend\n\nfunction Pathfinding:closeListAddPoint(point)\n    ASSERT_FUNC(iskindof(point,"PathPoint"))\n    self:listAddPoint_(self.m_closedList, point)\nend\n\nfunction Pathfinding:isCloseListContainsPoint(point)\n    ASSERT_FUNC(iskindof(point,"PathPoint"))\n    return self:listContainsPoint(self.m_closedList,point)\nend\n\nfunction Pathfinding:openListMinFPoint()\n    return self:listGetMinFPoint(self.m_openList)\nend\n\nfunction Pathfinding:openListAddPoint(point)\n    ASSERT_FUNC(iskindof(point,"PathPoint"))\n    self:listAddPoint_(self.m_openList, point)\nend\n\nfunction Pathfinding:isOpenListIsEmpty()\n    return self:listIsEmpty(self.m_openList)\nend\n\nfunction Pathfinding:openListRemovePoint(point)\n    ASSERT_FUNC(iskindof(point,"PathPoint"))\n    return self:listRemovePoint_(self.m_openList, point)\nend\n\nfunction Pathfinding:isOpenListContainsPoint(point)\n    ASSERT_FUNC(iskindof(point,"PathPoint"))\n    return self:listContainsPoint(self.m_openList,point)\nend\n\nfunction Pathfinding:getOpenListMinFPoint()\n    return self:listGetMinFPoint(self.m_openList)\nend\n\nfunction Pathfinding:getMapItemDataByXY(x,y)\n    if not self.m_mapData or not self.m_mapData[tonumber(x)] or not self.m_mapData[tonumber(x)][tonumber(y)] then\n        return\n    end\n    return self.m_mapData[tonumber(x)][tonumber(y)]\nend\n\nfunction Pathfinding:isReachableByXY(x,y)\n    if not self.m_reachableFunc then return true end -- if reachable function is not set,we want all postions are reachable.\n    local itemData = self:getMapItemDataByXY(x,y)\n    return itemData and self.m_reachableFunc(itemData)\nend\n\nfunction Pathfinding:isPointReadchable(point)\n    ASSERT_FUNC(iskindof(point,"PathPoint"))\n    return self:isReachableByXY(point:getX(),point:getY())\nend\n\nfunction Pathfinding:calcG(start,point)\n    local G = 1\n    local parentG = point:getParent() and point:getParent():getG() or 0\n    return G + parentG\nend\n\nfunction Pathfinding:calcH(endP,point)\n    return math.abs(point:getX() - endP:getX()) + math.abs(point:getY() - endP:getY())\nend\n\nfunction Pathfinding:notFoundPoint(tempStart,endP,point)\n    point:setParent(tempStart)\n    point:setG(self:calcG(tempStart,point))\n    point:setH(self:calcH(endP,point))\n    self:openListAddPoint(point)\nend\n\nfunction Pathfinding:foundPoint(tempStart,point)\n    local G = self:calcG(tempStart,point)\n    if G < point:getG() then\n        point:setParent(tempStart)\n        point:setG(G)\n    end\nend\n\nfunction Pathfinding:generatePoints(point)\n    local ret = {}\n    if point then\n        while point do\n            table.insert(ret, point)\n            point = point:getParent()\n        end\n    end\n    return ret\nend\n\n-- public api\n------------------------------------------------------------------\n\nfunction Pathfinding:setReachableFunction(func)\n    if not func then return end\n    ASSERT_FUNC(type(func) == \'function\')\n    self.m_reachableFunc = func\nend\n\nfunction Pathfinding:setMapData(mapData)\n    if not mapData then return end\n    ASSERT_FUNC(type(mapData) == \'table\')\n    self.m_mapData = mapData\nend\n\nfunction Pathfinding:findPath(startPoint,endPoint)\n    self:openListAddPoint(startPoint)\n    while not self:isOpenListIsEmpty() do\n        local tempPoint = self:openListMinFPoint()\n        self:openListRemovePoint(tempPoint)\n        self:closeListAddPoint(tempPoint)\n        if self:isCloseListContainsPoint(endPoint) then\n            return endPoint\n        end\n        local surroundPoints = self:getSurroundPoints(tempPoint)\n        for __,point in ipairs(surroundPoints) do\n            if self:isOpenListContainsPoint(point) then\n                self:foundPoint(tempPoint, point)\n            else\n                self:notFoundPoint(tempPoint, endPoint, point)\n            end\n        end\n        if self:isOpenListContainsPoint(endPoint) then\n            return self:isOpenListContainsPoint(endPoint)\n        end\n    end\n    return self:isOpenListContainsPoint(endPoint)\nend\n\n\nPathfinding.PathPoint = PathPoint\n\nreturn Pathfinding\n\n'})}),"\n",(0,o.jsx)(t.h1,{id:"\u4f7f\u7528",children:"\u4f7f\u7528"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lua",children:'local Pathfinding = require("Pathfinding")\nlocal PathPoint = Pathfinding.PathPoint\nfunction generalMapData()\n\tlocal map = {\n\t\t{0,0,0,0,0,0},\n\t\t{0,0,0,1,0,0},\n\t\t{0,0,0,1,0,0},\n\t\t{0,1,0,1,0,0},\n\t\t{0,0,0,0,0,0},\n\t\t{0,0,0,0,0,0}\n\t}\n\treturn map\nend\n\nfunction dumpMap(map)\n\tprint("------------")\n\tprint("-- Map Data")\n\tprint("------------")\n\tfor iR,row in ipairs(map) do\n\t\tif type(row) ~= \'table\' then return end\n\t\tfor iC,column in ipairs(row) do\n\t\t\tio.write(string.format("%s ",tostring(column)))\n\t\tend\n\t\tio.write("\\n")\n\tend\n\tprint("------------")\nend\n\nlocal data = generalMapData()\ndumpMap(data)\nlocal finder = Pathfinding.new(data,function(val)\n\treturn val ~= 1 \nend)\n\n-- test find way from 3,2 to 3,5\nlocal retPoint = finder:findPath(PathPoint.new(3,2),PathPoint.new(3,5))\nif retPoint then\n\twhile retPoint do\n\t\tdata[retPoint:getX()][retPoint:getY()] = "*"\n\t\tretPoint = retPoint:getParent()\n\tend\nend\ndumpMap(data)\n'})})]})}function c(n={}){const{wrapper:t}={...(0,a.R)(),...n.components};return t?(0,o.jsx)(t,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,t,e)=>{e.d(t,{R:()=>s,x:()=>r});var i=e(6540);const o={},a=i.createContext(o);function s(n){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function r(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(a.Provider,{value:t},n.children)}},8650:n=>{n.exports=JSON.parse('{"permalink":"/2016/findWay","source":"@site/blog/2016/findWay.md","title":"\u7528Lua\u5b9e\u73b0A*\u5bfb\u8def\u7b97\u6cd5","description":"\u5173\u4e8eA*\u5bfb\u8def\u7684\u7b97\u6cd5\u53c2\u8003\u8fd9\u7bc7\u6587\u7ae0","date":"2016-07-22T19:37:17.000Z","tags":[{"inline":true,"label":"Lua","permalink":"/tags/lua"}],"readingTime":4.555,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"\u7528Lua\u5b9e\u73b0A*\u5bfb\u8def\u7b97\u6cd5","date":"2016-07-22T19:37:17.000Z","tags":["Lua"]},"unlisted":false,"prevItem":{"title":"\u4ee5ABS\u5b8f\u4e3a\u4f8b\u8bf4\u8bf4Clang\u4e2d\u7684\u5b8f\u5b9a\u4e49\u65b9\u5f0f\u6280\u5de7","permalink":"/2016/thinking-about-macro"},"nextItem":{"title":"WindowsPhone\u7684TextBox\u591a\u884c\u652f\u6301\u53ca\u7591\u95ee","permalink":"/2016/multiline-textbox-wp8-1"}}')}}]);